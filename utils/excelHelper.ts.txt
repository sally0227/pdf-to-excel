import * as XLSX from 'xlsx';
import { PageDataMap } from "../types";

export const downloadExcel = (data: PageDataMap, filename: string, mode: 'merge' | 'split') => {
  const wb = XLSX.utils.book_new();

  if (mode === 'merge') {
    // Mode 1: Merge all pages into one big sheet
    let allRows: string[][] = [];
    
    // Sort pages naturally (1, 2, 3...)
    const sortedPages = Object.keys(data).sort((a, b) => {
      const numA = parseInt(a.replace(/\D/g, '')) || 0;
      const numB = parseInt(b.replace(/\D/g, '')) || 0;
      return numA - numB;
    });

    sortedPages.forEach(pageKey => {
      const pageRows = data[pageKey];
      // Optional: Add a visual separator row if merging, but user asked for raw data mainly.
      // We will just append them.
      allRows = [...allRows, ...pageRows];
      // Add an empty row between pages for readability
      allRows.push([]); 
    });

    const ws = XLSX.utils.aoa_to_sheet(allRows);
    XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

  } else {
    // Mode 2: One sheet per page
    const sortedPages = Object.keys(data).sort((a, b) => {
      const numA = parseInt(a.replace(/\D/g, '')) || 0;
      const numB = parseInt(b.replace(/\D/g, '')) || 0;
      return numA - numB;
    });

    sortedPages.forEach(pageKey => {
      // Create a clean sheet name (e.g., "Page 1")
      let sheetName = pageKey.includes("Page") || pageKey.includes("È†Å") ? pageKey : `Page ${pageKey}`;
      // Excel sheet names max 31 chars
      sheetName = sheetName.substring(0, 31);
      
      const ws = XLSX.utils.aoa_to_sheet(data[pageKey]);
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
    });
  }

  // Generate file and trigger download
  XLSX.writeFile(wb, filename);
};